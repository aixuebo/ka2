一、配置文件
product有一个配置文件
consumer有一个配置文件
logManager有一个LogConfig配置文件
OffsetManager类有一个OffsetManagerConfig配置文件
KafkaConfig 一个broker一个配置文件,用于配置该节点的host、port等信息

二、topic的结构
topic名字
partition结构集合
属性:
NoLeaderNodeId 如果是-1表示没有为partition设置leader,即该topic的所有partition是不具备高可用的

三、partition结构
partitionId 属于第几个partition
leaderId 该partition的leader所在的brokerId
leader 该leaderId对应的Broker对象
replicaIds 该备份的Broker节点ID集合
replicas 该备份的Broker节点Broker对象集合
isrIds
isr

四、isr的意义(即in-sync Replica),是确保备份的节点已经获取拉去到了最新的信息
Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）
如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除。
这里所描述的“落后太多”指Follower复制的消息落后于Leader后的条数超过预定值
（该值可在$KAFKA_HOME/config/server.properties中通过replica.lag.max.messages配置，其默认值是4000）或者
Follower超过一定时间（该值可在$KAFKA_HOME/config/server.properties中通过replica.lag.time.max.ms来配置，其默认值是10000）未向Leader发送fetch请求。

Kafka在ZooKeeper中动态维护了一个ISR（in-sync replicas），这个ISR里的所有Replica都跟上了leader，只有ISR里的成员才有被选为Leader的可能。
在这种模式下，对于f+1个Replica，一个Partition能在保证不丢失已经commit的消息的前提下容忍f个Replica的失败。在大多数使用场景中，这种模式是非常有利的。

Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica）
，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一
致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。

五、HW 应该表示leader上的已经被提交单额日志队列
Consumer读消息也是从Leader读取，只有被commit过的消息（offset低于HW的消息）才会暴露给Consumer。

六、如何选举Leader
最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。

但是该方法会有3个问题：
split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致
herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整
ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。


Kafka 0.8.*的Leader Election方案解决了上述问题，
它在所有broker中选出一个controller，
所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。

---------------------------------
