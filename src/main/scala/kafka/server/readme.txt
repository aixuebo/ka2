一、KafkaServer
 代表一个kafka的单节点,该类控制该节点的生命周期
 处理该节点的启动和关闭服务功能

是一个服务器节点的入口,是通过kafka.Kafka 是整个程序的入口类调用的。

二、需要哪些服务
1.连接zookeeper
2.LogManager 用于在该节点存储topic-partition的日志服务
3.new SocketServer在该节点开通一个服务端socket,用于接收各种服务命令
4.new KafkaRequestHandlerPool(config.brokerId, socketServer.requestChannel, apis, config.numIoThreads) 处理socket的请求,从该socketserver中不断拿到request请求去处理
5.KafkaHealthcheck 用于将该broker节点的信息注册到zookeeper中,并且当节点失效的时候,继续重新注册到zookeeper的过程。
6.TopicConfigManager 当topic的配置文件发生变化的时候,要更新LogManager中每一个Topic-partition对应的配置对象
7.ReplicaManager
8.OffsetManager 用于存储group-topic-partition的offset信息的配置 ,即每一个消费组消费每一个topic-partition到哪个序号了
                只有存储该topic的log节点上或者备份节点上有该对象,但是每一个节点都会产生一个该对象,只是可能该对象没有意义
9.KafkaController


三、整体流程
1.用户先产生一个topic,协商好要拥有几个partition,以及备份因子
2.程序会自动产生每一个partition的备份节点在哪里,并且将其写入到zookeeper的topic中
3.当controller启动的时候,会加载所有的topic内容,因此就知道topic-partition-备份节点集合之间的关系了
4.当集群运行中,新产生一个topic,因为controller.PartitionStateMachine监听了/brokers/topics,因此会通知controller创建该topic以及读取zookeeper,创建对应的partition对象,添加到zookeeper映射中。
此时partition是new状态。同时也会产生备份对象,会经过ReplicaStateMachine状态机处理



已经解决的问题
1.partition的getOrCreateReplica方法,为什么要与log.logEndOffset的进行比较,获取较小的值,创建备份对象
可能日志很大,但是leader的同步节点集合最小的位置比该日志的内容要小,因此要设置该值为最小的值

2.Replica里 这个字段什么含义,为什么在readMessageSet里面的时候,leader要返回给follower
@volatile private[this] var highWatermarkMetadata: LogOffsetMetadata = new LogOffsetMetadata(initialHighWatermarkValue)
答案:因为要告诉每一个客户端follower节点,当前leader已经同步到哪些位置了,即所有的同步集合都至少也拿到了该位置的数据了。该位置之前的数据都已经全部同步完成


未解之谜
因为topic的partition在哪些节点上,zookeeper上是有记录的
因此在这些节点上才能找到对应的partition

kafkaApi上getTopicMetadata是获取每一个topic的partition详细信息,但是不太知道controller是把所有的topic都同步到所有活着的节点上了么？
我理解的是只是会同步该节点上已经存在的partiion啊

如果controller正在切换中,那么此时如果有请求的话,是等待还是返回已经缓存的结果呢？
当partition的leader正在切换节点的时候.有请求该partition的信息的时候,应该是什么样的情况呢？
